
一、内存逃逸

	1、概念
	在Go语言中，内存逃逸(Memory Escape）是指变量或对象在栈上创建后，因某些原因被转移到堆上分配内存，从而导致该对象的生命周期不再受栈的限制。简单来说，内存逃逸是指一个变量原本应该分配在栈上，但由于其引用的生命周期超出了当前作用域，导致它被分配到堆上。

	Go的垃圾回收机制（GC）负责管理内存，决定何时回收堆上的对象。在性能优化中，**栈分配**比**堆分配**更高效，因为栈分配和销毁的成本较低。栈上的对象在函数返回时就会自动销毁，而堆上的对象则需要垃圾回收器来回收。

	2、什么场景下会发生内存逃逸？
	
	（1）引用传递给外部函数：
		当一个局部变量的引用（指针）被传递给了当前函数外部的某个 Goroutine 或函数，Go 认为这个变量的生命周期超出了当前函数的作用域，因此会将其从栈上移动到堆上。
		
	（2）闭包引用局部变量：
		如果一个局部变量被闭包函数引用，那么 Go 会认为该变量的生命周期超出了原函数的作用域。因此，闭包中的引用会导致该变量分配在堆上。
		
	（3）数组或切片的切片操作：
		如果你对一个数组或切片做切片操作，并且这个切片引用了数组的某个部分（或者切片本身的引用被传递给了外部），Go 会认为这个引用的生命周期超出了当前作用域，因此可能会将原始数组或切片的内存逃逸到堆上。
	（4）存活周期超过栈的局限性：
		如果某个变量的生命周期在栈上创建时无法确定，Go 编译器会选择将它分配在堆上，而不是栈上。比如，多个 Goroutine 在不同的线程中访问该变量时，编译器可能会认为它需要在堆上分配，以保证它可以跨线程访问。

二、内存对齐机制

	1、概念
		内存对齐，是指内存地址是所存储数据大小（按字节为单位）的整数倍，以便CPU可以一次将该数据从内存中读取出来。
		为了能让CPU可以更快的存取到各个字段，Go编译器会帮你把struct结构体做数据的对齐。

三、内存

	1、内存模型
		Go 语言采用了堆（Heap）和 栈（Stack）两种内存区域来分配内存：
	
		栈：用于存储函数的局部变量、参数等。栈内存分配和回收非常高效，且每个 goroutine 都有自己的栈。栈的大小是有限的（一般从 2 KB 到 1 MB），当栈空间不足时，Go 运行时会动态扩展栈的大小，扩展时会将栈内容复制到更大的空间。栈内存采用的是**LIFO**（后进先出）结构，因此回收时非常简单。
	    
		堆：用于存储动态分配的内存，例如通过 `new` 或 `make` 创建的对象。堆内存的管理较为复杂，因为它需要垃圾回收机制来追踪不再使用的内存并回收它。堆的内存可以被多个 goroutine 共享，但需要通过同步原语（如锁）来保护。

	Go 的内存分配不要求开发者手动管理内存，程序员不需要调用 `malloc` 或 `free` 来管理内存，内存的分配和回收由 Go 的运行时和垃圾回收器自动完成。

	2、内存分配
		Go 提供了多种内存分配方式，主要包括：

	（1）栈分配：局部变量、函数参数等都在栈上分配内存。栈分配的内存非常高效，因为栈内存的分配是按顺序进行的，且不需要复杂的内存管理操作。
	（2）堆分配：当局部变量或数据结构的生命周期超出了当前函数的范围时，它们会被分配到堆上。堆内存管理比较复杂，需要依赖垃圾回收器来回收不再使用的内存。
	（3）内存池：Go 提供了 `sync.Pool` 用于对象池的管理，能够复用一些临时对象，从而减少频繁的内存分配和回收，提高性能。

	内存分配时，Go 运行时会决定是分配到栈上还是堆上。通常，如果一个对象的生命周期仅限于函数内，它会分配到栈上；如果对象的生命周期跨越了函数调用，或者它是通过 goroutine 共享的，它会分配到堆上。

	3、内存分配器
		Go 的内存分配器负责管理堆内存的分配，它由以下几部分组成：

	（1）小对象分配：Go 的内存分配器将堆内存分为多个不同大小的区域，并为每个区域提供不同的分配策略。对于较小的对象，Go 会通过内存池（mcache）来复用内存块，从而提高分配效率。对于较大的对象，Go 会直接向操作系统请求内存。
    
	（2）对象池：`sync.Pool` 提供了一个对象池的机制，用于缓存和复用临时对象，减少频繁的内存分配和回收。`sync.Pool` 使用了类似生产者-消费者模式来存储和管理对象，可以显著提升性能，尤其是在需要频繁分配小对象的场景中。
    
	（3）垃圾回收与内存分配：在垃圾回收过程中，Go 的分配器会将不再使用的内存标记为可回收的，并将其返回给内存池。通过垃圾回收，内存分配器能够控制堆内存的增长，避免内存泄漏。