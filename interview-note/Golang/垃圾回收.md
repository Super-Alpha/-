
一、概念

	1、垃圾回收
		垃圾回收（Garbage Collection，GC）是一种自动进行的内存管理机制，它的核心任务是在程序运行期间监测和回收那些不再被使用的对象，从而防止内存泄漏并提升内存的使用效率。
	
	2、垃圾
		所谓”垃圾“是指那些程序中已经分配出去但不再被引用的内存空间。这些无用的内存如果未被及时清理，就会逐渐积累，最终可能导致内存资源的浪费和程序性能的下降。

	3、堆数据区
		（1）堆是用于存储程序运行时动态创建的对象和数据结构的内存区域。
		（2）堆内存的分配是动态的，由程序员通过特定的内存分配函数（如C/C++中的`malloc`或`new`）进行。
		（3）堆内存的回收通常由垃圾回收器（Garbage Collector, GC）负责，它会自动追踪并回收不再被程序使用的对象，防止内存泄漏。
		
	4、栈数据区
		（1）栈用于存储局部变量、函数调用的上下文等。
		（2）栈内存的分配和回收是自动的，由编译器管理，其生命周期与函数调用的作用域紧密相关。
		（3）栈的大小通常是固定的，但可以通过系统参数进行调整。
	
	5、全局/静态数据区
		（1）这些区域存储程序启动时分配的数据，如全局变量和静态变量。
		（2）它们的生命周期与程序的运行周期一致，因此不需要垃圾回收器管理。

	6、STW（stop-the-world）
		即暂停程序所有业务逻辑的执行。

	垃圾主要产生于程序运行过程中的内存分配与回收不当。在现代操作系统中，每个进程都拥有独立的虚拟内存空间，这些空间被划分为不同的内存段，包括代码段、数据段、BSS段、堆段、文件映射段和栈段。其中，堆和栈是存储动态分配内存的两个关键区域。

二、Golang垃圾回收机制

	1、三色标记法
		三色标记法将所有对象分为三种状态：白色、黑色、灰色，以此来进行并发垃圾回收
		
		白色：未被垃圾回收器访问的对象，可能是活跃的，也可能是垃圾。
		灰色：活跃的对象，已被标记但尚未完成所有子对象的标记。
		黑色：活跃的对象，已完全标记，包括其所有子对象。

	2、三色标记法工作流程
	（1）初始化
		将所有的对象初始化为白色，表示它们尚未被访问；
	
	（2）并发标记
		每次垃圾回收开始，首先从根对象开始，垃圾回收器并发地遍历对象图，其所有直接可达的对象标记为灰色，并将这些对象加入到工作队列中；
	
	（3）处理工作队列
		垃圾回收器会从工作队列中取出对象，继续标记它们的子对象，直到所有子对象都被标记，一旦一个对象的所有子对象都被标记，该对象就会从工作队列中移除，并标记为黑色；
	
	（4）结束并发标记
		当工作队列清空，且没有更多对象需要标记时，垃圾回收器结束并发标记阶段；
	
	（5）清除阶段
		所有白色对象（即未被标记的对象）被认为是垃圾，垃圾回收器将这些对象进行回收。
	
	3、强/弱三色不变式
		在并发垃圾回收过程中，当不采用STW（Stop-The-World）机制进行保护时，可能会出现这样的情况：一个白色对象（即未被标记为活跃的对象，可能被垃圾回收器误认为是垃圾）被黑色对象（已确认为活跃的对象）引用。同时，一个灰色对象（正在被标记的对象）与该白色对象之间的引用关系被破坏，那么白色对象可能会被错误地回收，因为它不再有任何已知的活跃引用。这可能导致程序崩溃，因为黑色对象尝试访问一个已经被回收的内存区域。因此为确保正确地识别和回收不再使用的内存，同时避免活跃对象被错误回收，引入了强弱三色不变式的概念：

	（1）强三色不变式:强三色不变式要求在垃圾回收过程中，黑色对象不得引用白色对象。这一规则确保了所有被黑色对象引用的一定是活跃的，从而防止了活跃的白色对象被错误回收。
	
	（2）弱三色不变式:弱三色不变式则允许黑色对象引用白色对象，但要求白色对象存在其他灰色对象对它的引用，或者可达它的链路上游存在灰色对象，防止它被回收。

	4、写屏障机制
		写屏障是并发垃圾回收中的关键技术，用于确保在对象引用发生变更时，垃圾回收器能够正确地维护对象的标记状态。

	（1）Go-V1.5采用：
		插入写屏障: 当一个黑色对象A引用一个白色对象B时，触发插入写屏障。具体操作是将B对象标记为灰色，确保B对象不会被错误地当作垃圾回收。这一机制维护了强三色不变式，即不存在黑色对象引用白色对象的情况。对于栈上的对象，由于没有插入写屏障，垃圾回收器会在适当的时候启动STW，重新扫描栈上的空间，以确保所有活跃的对象都被正确标记。

		删除写屏障: 当一个对象的引用被删除时，触发删除写屏障。如果被删除引用的对象是白色的，它会被暂时标记为灰色，这样可以保护它不被当前周期的垃圾回收器回收，实现了弱三色不变式。这意味着，即使一个对象的最后一个引用被删除，只要存在从灰色对象到该白色对象的路径，该白色对象就不会被立即回收。

	通过这两种写屏障，Go语言的垃圾回收器能够在不牺牲程序性能的前提下，准确地追踪对象的活跃状态，并有效地执行垃圾回收。这些机制的引入，提高了并发垃圾回收的安全性和效率。

	（2）Go-1.8采用：
	混合写屏障机制：(针对栈空间的处理)
		- 在GC开始时，栈上的所有对象被扫描并标记为黑色，避免了对栈的二次扫描，减少了STW的需要。
		- GC进行期间，任何新在栈上创建的对象默认被视为黑色。
		- 被删除的对象标记为灰色。
		- 被添加的对象标记为灰色。
	混合写屏障机制满足了一种变形的弱三色不变式，确保了在并发环境下，对象的引用变更得到正确处理，同时减少了对STW的依赖。

	混合写屏障的应用场景：
		堆到栈的引用变更: 当一个堆对象删除对另一个对象的引用，而该对象成为另一个栈对象的下游时，该对象被标记为灰色，类似于删除写屏障的行为。
		栈到栈的引用变更: 当一个栈对象删除对另一个对象的引用，而该对象成为另一个栈对象的下游时，该对象保持黑色状态，如果没有成为另一个栈对象的下游，可能会在后续的GC周期中被回收。
		堆到堆的引用变更: 当一个堆对象删除对另一个对象的引用，而该对象成为另一个堆对象的下游时，该对象被标记为灰色，类似于删除写屏障的行为。
		栈到堆的引用变更: 当一个栈对象删除对另一个对象的引用，而该对象成为另一个堆对象的下游时，该对象保持黑色状态，确保了弱三色不变式的维持。

	通过这些场景的处理，混合写屏障机制确保了在并发垃圾回收过程中，对象的生命周期得到正确的管理，同时提高了垃圾回收的效率和程序的响应性。

	（3）屏障的作用：
		避免程序运行过程中，变量被误回收；
		减少STW的时间；

	5、垃圾回收调优措施
	（1）减少垃圾生成：
		尽量避免产生大量短生命周期的对象，减少GC的压力；
	（2）使用对象池：
		如果程序中存在频繁创建和销毁对象的场景，可以考虑使用对象池，如sync.pool来复用对象，减少GC的压力；
	（3）合理设置GOGC：
		可以通过设置GOGC环境变量来控制垃圾回收的触发频率，如果希望减少GC的频率，可以适当增加GOGC的值。GOGC是垃圾回收的增长阈值，表示堆的增长倍数；例如，默认值GOGC= 100，表示堆的大小增加到当前堆的两倍时触发垃圾回收。

	6、总结
	
	在Go语言的发展过程中，垃圾回收（GC）机制经历了显著的改进，以提高性能并减少对程序运行的影响：

	Go V1.3: 采用传统的标记-清除法，整个过程需要完全暂停程序（STW），进行内存的可达性分析和垃圾回收。这种方法效率较低，因为程序在GC期间无法执行用户逻辑。  
    
	Go V1.5: 引入了三色标记法，这是一种并发的垃圾回收策略，通过引入写屏障来处理堆空间中的内存引用变化。尽管在处理栈空间时仍需要STW，但这一版本显著减少了GC过程中的暂停时间，提高了效率。  
    
	Go V1.8: 进一步优化了三色标记法，并引入了混合写屏障机制。在这一版本中，栈空间的处理得到了改进。这些改进使得Go语言的垃圾回收整体过程几乎不需要STW 注注2 。

	总体来看，Go语言的垃圾回收机制从V1.3到V1.8经历了从完全STW到几乎无需STW的重大转变。这些改进不仅提高了垃圾回收的效率，也使得Go语言更适合需要高吞吐量和低延迟的应用程序。随着Go语言的不断发展，我们可以期待垃圾回收机制将继续优化，以满足日益增长的性能需求。