
一、GPM调度器

	1、概念
	
	（1）Go调度器
		Go调度本质是把大量的Goroutine分配到少量的线程上去执行，并利用多核并行实现更强大的并发。
	（2）线程
		线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。

	2、Goroutine特点：
		占用内存更小（仅几kb）
		调度更灵活（runtime调度）

	3、GPM模型
		G：表示Goroutine，是一个待执行的任务
		P：表示处理器，可以被看作运行在线程上的本地调度器
		M：表示操作系统线程，由操作系统的调度器调度和管理
	
	线程是运行Goroutine的实体，调度器的功能是把可运行的Goroutine分配到工作线程上。

![[Pasted image 20241204200556.png]]
	
	（1）全局队列：存放等待运行的G
	
	（2）本地队列：存放的也是等待运行的G，存的数量有限，不超过256个。新建G’时，G’优先加入到P的本地队列，如果队列满了，则会把本地队列中一半的G移动到全局队列。

	（3）P列表：所有的P都在程序启动时创建，并保存在数组中，最多有GOMAXPROCS个。

	（4）M：线程想运行任务就得获取P，从P的本地队列获取G，P队列为空时，M也会尝试从全局队列拿一批G放到P的本地队列，或从其他P的本地队列偷一半放到自己P的本地队列。M运行G，G执行之后，M会从P获取下一个G，不断重复下去。

	Goroutine调度器和OS调度器是通过M结合起来的，每个M都代表1个内核线程，OS调度器负责把内核线程分配到CPU的内核上执行。

	4、Go调度器设计策略
		
		复用线程：避免频繁的创建、销毁线程，而是对线程的复用
	
	（1）work stealing机制
		当本线程无可运行的G时，尝试从其他线程绑定的P偷取G，而不是销毁线程。

	（2）hand off机制
			当本线程因为G进行‘系统调用’阻塞时，线程释放绑定的P，把P转移给其它空闲的线程执行。
	
	5、go func()调度流程
	
![[Pasted image 20241204202304.png]]

	结论：
	我们通过 go func()来创建一个goroutine；
	
	有两个存储G的队列，一个是局部调度器P的本地队列、一个是全局G队列。新创建的G会先保存在P的本地队列中，如果P的本地队列已经满了就会保存在全局的队列中；
	
	G只能运行在M中，一个M必须持有一个P，M与P是1：1的关系。M会从P的本地队列弹出一个可执行状态的G来执行，如果P的本地队列为空，就会想其他的MP组合偷取一个可执行的G来执行；
	
	一个M调度G执行的过程是一个循环机制；
	
	当M执行某一个G时候如果发生了系统调用或则其余阻塞操作，M会阻塞，如果当前有一些G在执行runtime会把这个线程M从P中摘除(detach)，然后再创建一个新的操作系统的线程(如果有空闲的线程可用就复用空闲线程)来服务于这个P；
	
	当M系统调用结束时候，这个G会尝试获取一个空闲的P执行，并放入到这个P的本地队列。如果获取不到P，那么这个线程M变成休眠状态， 加入到空闲线程中，然后这个G会被放入全局队列中。


	6、M0和G0
		（1）M0
			M0是启动程序后的编号为0的主线程，这个M对应的实例会在全局变量runtime.m0中，不需要在heap上分配，M0负责执行初始化操作和启动第一个G，在之后M0就和其他的M一样了。
		（2）G0
			​G0是每次启动一个M都会第一个创建的gourtine，G0是仅用于负责调度的G，G0不指向任何可执行的函数, 每个M都会有一个自己的G0。