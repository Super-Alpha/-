	1、三次握手

![[Pasted image 20241208175346.png]]

	假设发送端为客户端，接收端为服务端。开始时客户端和服务端的状态都是CLOSE：

		第一次握手：客户端向服务端发起建立连接请求，客户端会随机生成一个起始序列号x，客户端向服务端发送的字段中包含标志位SYN=1，序列号seq=100。第一次握手前客户端的状态为CLOSE，第一次握手后客户端的状态为SYN-SENT。此时服务端的状态为LISTEN
		 第二次握手：服务端在收到客户端发来的报文后，会随机生成一个服务端的起始序列号y，然后给客户端回复一段报文，其中包括标志位SYN=1，ACK=1，序列号seq=y，确认号ack=x+1。第二次握手前服务端的状态为LISTEN，第二次握手后服务端的状态为SYN-RCVD，此时客户端的状态为SYN-SENT。（其中SYN=1表示要和客户端建立一个连接，ACK=1表示确认序号有效）
		第三次握手：客户端收到服务端发来的报文后，会再向服务端发送报文，其中包含标志位ACK=1，序列号seq=x+1，确认号ack=y+1。第三次握手前客户端的状态为SYN-SENT，第三次握手后客户端和服务端的状态都为ESTABLISHED。
	
	需要注意的一点是，第一次握手，客户端向服务端发起建立连接报文，会占一个序列号。但是第三次握手，同样是客户端向服务端发送报文，这次却不占序列号，所以建立连接后，客户端向服务端发送的第一个数据的序列号为x+1。

	2、四次挥手
	
![[Pasted image 20241208175356.png]]

	第一次挥手：客户端向服务端发送的数据完成后，向服务端发起释放连接报文，报文包含标志位FIN=1，序列号seq=u。此时客户端只能接收数据，不能向服务端发送数据。
	第二次挥手：服务端收到客户端的释放连接报文后，向客户端发送确认报文，包含标志位ACK=1，序列号seq=v，确认号ack=u+1。此时客户端到服务端的连接已经释放掉，客户端不能像服务端发送数据，服务端也不能向客户端发送数据。但服务端到客户端的单向连接还能正常传输数据。
	第三次挥手：服务端发送完数据后向客户端发出连接释放报文，报文包含标志位FIN=1，标志位ACK=1，序列号seq=w，确认号ack=u+1。
	第四次挥手：客户端收到服务端发送的释放连接请求，向服务端发送确认报文，包含标志位ACK=1，序列号seq=u+1，确认号ack=w+1。


	3、为什么TCP连接的时候是3次？两次是否可以？
		不可以，主要从以下两方面考虑（假设客户端是首先发起连接请求）：
		
		（1）假设建立TCP连接仅需要两次握手，那么如果第二次握手时，服务端返回给客户端的确认报文丢失了，客户端这边认为服务端没有和他建立连接，而服务端却以为已经和客户端建立了连接，并且可能向服务端已经开始向客户端发送数据，但客户端并不会接收这些数据，浪费了资源。如果是三次握手，不会出现双方连接还未完全建立成功就开始发送数据的情况。
		（2）如果服务端接收到了一个早已失效的来自客户端的连接请求报文，会向客户端发送确认报文同意建立TCP连接。但因为客户端并不需要向服务端发送数据，所以此次TCP连接没有意义并且浪费了资源。

	4、为什么TCP连接的时候是3次，关闭的时候却是4次？
		因为需要确保通信双方都能通知对方释放连接，假设客服端发送完数据向服务端发送释放连接请求，当客服端并不知道，服务端是否已经发送完数据，所以此次断开的是客户端到服务端的单向连接，服务端返回给客户端确认报文后，服务端还能继续单向给客户端发送数据。当服务端发送完数据后还需要向客户端发送释放连接请求，客户端返回确认报文，TCP连接彻底关闭。所以断开TCP连接需要客户端和服务端分别通知对方并分别收到确认报文，一共需要四次。


	5、TIME_WAIT和CLOSE_WAIT的区别在哪?
		默认客户端首先发起断开连接请求

		CLOSE_WAIT是被动关闭形成的，当客户端发送FIN报文，服务端返回ACK报文后进入CLOSE_WAIT。
		TIME_WAIT是主动关闭形成的，当第四次挥手完成后，客户端进入TIME_WAIT状态。

	6、为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？
		MSL的意思是报文的最长寿命，可以从两方面考虑：

		（1）客户端发送第四次挥手中的报文后，再经过2MSL，可使本次TCP连接中的所有报文全部消失，不会出现在下一个TCP连接中。
		（2）考虑丢包问题，如果第四挥手发送的报文在传输过程中丢失了，那么服务端没收到确认ack报文就会重发第三次挥手的报文。如果客户端发送完第四次挥手的确认报文后直接关闭，而这次报文又恰好丢失，则会造成服务端无法正常关闭。


	7、如果已经建立了连接，但是客户端突然出现故障了怎么办？
	
		如果TCP连接已经建立，在通信过程中，客户端突然故障，那么服务端不会一直等下去，过一段时间就关闭连接了。具体原理是TCP有一个保活机制，主要用在服务器端，用于检测已建立TCP链接的客户端的状态，防止因客户端崩溃或者客户端网络不可达，而服务器端一直保持该TCP链接，占用服务器端的大量资源(因为Linux系统中可以创建的总TCP链接数是有限制的)。
		保活机制原理：设置TCP保活机制的保活时间keepIdle，即在TCP连接超过该时间没有任何数据交互时，发送保活探测报文；设置保活探测报文的发送时间间隔keepInterval；设置保活探测报文的总发送次数keepCount。如果在keepCount次的保活探测报文均没有收到客户端的回应，则服务器端即关闭与客户端的TCP连接。

	8、TCP 如何保证传输的可靠性？
	
	（1）握/挥手机制：连接和断开的可靠性，连接时采用三次握手机制，断开时采用四次挥手机制；
	
	（2）序列号：利用序列号保证数据包有序，并且按序列号进行排序和数据包去重；
	
	（3）校验和：数据在传输过程中如果发生变化，那么校验和就会产生差别，TCP会丢弃这个报文段，并且不会发送ACK确认；
	
	（4）确认和重传：TCP使用确认和重传机制来确保数据的可靠传输。发送方在发送数据后，会等待接收方发送确认（ACK）信号。如果发送方在合理的时间内未收到确认，就会认为数据丢失，触发重传机制，重新发送数据。
	
	（5）流量控制：TCP每一方都有固定大小的缓冲空间，滑动窗口控制；根据接收方的处理速率，能够给发送方进行反馈，发送方能够去调整发送的速率，防止包丢失。针对接收者而言。
	
	（6）拥塞控制：网络拥塞时，减少数据发送，TCP发送数据由两个变量控制，接受方接受速率，网络拥塞（延迟）程度，发送方发送的数据的大小是滑动窗口和拥塞窗口的最小值。针对网络而言。
		
	注意：
		拥塞控制是TCP协议中的一种重要机制，用于在网络拥塞时调整数据传输的速率，以确保网络的稳定性和公平性。TCP 拥塞控制包括以下几个过程：
		
		1）满启动：
			当 TCP 连接建立或者在网络中断重连后，慢启动阶段开始。发送端维护一个叫做拥塞窗口（cwnd）的变量，初始值为一个较小的数值（通常为1个报文段大小）；在每次收到对方的确认时，拥塞窗口大小翻倍，即指数增长，这样发送端可以逐渐增加发送的数据量。慢启动阶段持续到拥塞窗口达到一个阈值（拥塞避免阈值）
			
		2）拥塞避免：
			一旦拥塞窗口达到拥塞避免阈值，TCP进入拥塞避免阶段。拥塞避免阶段中，每经过一个往返时间（RTT），拥塞窗口大小只增加1个报文段大小，即线性增长。这种线性增长的方式更加稳健，可以缓解网络拥塞可能导致的问题。
			
		3）快重传：
		如果发送端连续收到3个重复的确认（Duplicate ACK），就认为某个报文段丢失了。在收到第三个重复确认时，发送端立即重传丢失的报文段，而不是等待超时重传触发。这样可以更快地恢复丢失的报文段，减少数据重传的延迟。
		
		4）快恢复：
		发送端将拥塞窗口减半，并设置拥塞避免阈值为当前拥塞窗口的一半。然后，发送端继续执行拥塞避免算法，即每个RTT只增加一个报文段大小。快速恢复阶段旨在降低拥塞窗口的大小，以减少对网络的负载，同时保持连接的稳定性。