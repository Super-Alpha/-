
一、缓存一致性-旁路缓存
	
	1、流程
	
		（1）先读取缓存，若命中，则返回数据；
		（2）若未命中，则读取数据库；
		（3）读取数据库后，更新缓存中的数据；
	
	2、更新方案
	
	（1）先更新缓存，再更新数据库
		如果更新缓存成功，更新数据库失败，则导致数据不一致
		
	（2）先更新数据库，再更新缓存
		如果更新数据库成功，更新缓存失败，则导致数据不一致
		
	（3）先删除缓存，再更新数据库
		删除缓存，成功与否，都不会导致数据不一致问题；
		
		缺点：在多线程环境下，可能出现其它线程在缓存删除后，读取数据并写入缓存的情况，导致数据不一致。
		例如：A线程先删除缓存后，此时，B线程读取数据，缓存中没有数据，则读取数据库并将旧数据更新到缓存；之后，A线程又更新数据库数据。进而导致缓存中数据和数据库中数据不一致（即缓存中是旧数据，数据库中是新数据）。
		
	（4）先更新数据库，再删除缓存
		
		若更新数据库成功，删除缓存成功，理想状态；
		若更新数据库成功，删除缓存失败，会导致短时间的数据不一致，因为缓存设置有有效期；
		若更新数据库失败，不会删除缓存，不存在数据不一致情况；

		在多线程并发情况下，可能会导致短暂的数据不一致：
		
		例如：A线程更新数据库a=10，然后删除了缓存；此时B线程查询a数据，在尚未更新a缓存情况下，此时C线程更新了数据库a=20，然后执行删除缓存；最后，B又更新了缓存a=10；进而导致数据不一致。
		
		这种情况出现概率极低，因为更新缓存的操作，比更新数据库的操作快好几个数量级。若避免此类情况出现，可给缓存设置有效期，可能会导致短暂时间的数据不一致。


	3、在上述方案基础上的补充机制，用户进一步保障数据的一致性
	
		（1）延时双删策略
			先删除缓存，再更新数据库，等待一段时间（注：要大于缓存更新时间）再次删除缓存
			
			优点：在多线程环境下，可以防止其它线程读取到旧数据并存入缓存
			缺点：有短时间的数据不一致

		（2）采用分布式锁
			在更新数据前，获取分布式锁，确保只有一个线程能够操作缓存和数据库；完成数据更新后，再释放锁。
			优点：保证操作的强一致性，避免并发导致的数据不一致问题
			缺点：需要额外的锁管理和实现复杂度

	4、总结
		通过上面四种情况，可以发现，删除缓存策略比更新缓存策略更好，因为删除缓存策略只有在多线程并发情况下，才会出现数据不一致问题。
		通常情况下，先删除缓存再更新数据库的方案加上延时双删，可以较好的保证数据一致性；在需要严格一致性的场景下，使用分布式锁是更优的选择。


二、缓存异常问题

	1、缓存穿透
		概念：
			指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，进而给数据库带来压力。
		
		解决措施：
		（1）如果是非法请求参数，在API入口针对参数进行校验，过滤非法值。
		（2）设置空值或者默认值，并指定过期时间；
		（3）使用布隆过滤器拦截；
	
	2、缓存击穿
		概念：
			指热点key在某个时间点过期的时候，而恰好在这个时间点对这个Key有大量的并发请求过来，从而大量的请求打到数据库。
	
		解决措施：
		（1）针对热点key，设置永不过期
		（2）使用分布式互斥锁
			
	3、缓存雪崩
		概念：
		 指缓存中数据大批量到过期时间，而查询数据量巨大，请求都直接访问数据库，引起数据库压力过大甚至down机。
		 解决措施：
		 （1）均匀设置过期时间
		 （2）Redis故障导致宕机也可能引起缓存雪崩，这就需要构造Redis高可用集群保障

三、key过期策略

	1、定时过期
		每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即对key进行清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。
		
	2、惰性过期
		只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。
		
	3、定期过期
		每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。

四、内存淘汰策略
	
	1、- volatile-lru：当内存不足以容纳新写入数据时，从设置了过期时间的key中使用LRU（最近最少使用）算法进行淘汰。
	
	2、 allkeys-lru：当内存不足以容纳新写入数据时，从所有key中使用LRU（最近最少使用）算法进行淘汰。
	
	3、volatile-lfu：当内存不足以容纳新写入数据时，在过期的key中，使用LFU算法进行删除key。
	
	4、 allkeys-lfu：当内存不足以容纳新写入数据时，从所有key中使用LFU算法进行淘汰。
	
	5、volatile-random：当内存不足以容纳新写入数据时，从设置了过期时间的key中，随机淘汰数据。
	
	6、 allkeys-random：当内存不足以容纳新写入数据时，从所有key中随机淘汰数据。
	
	7、 volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的key中，根据过期时间进行淘汰，越早过期的优先被淘汰。
	
	8、noeviction：默认策略，当内存不足以容纳新写入数据时，新写入操作会报错。