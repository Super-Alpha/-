
1、为什么Redis这么快？

![[Pasted image 20241208145143.png]]

	1.1 基于内存存储实现
		Redis基于内存存储实现的数据库，相对于数据存在磁盘的MySQL数据库，省去磁盘I/O的消耗。

	1.2 高效的数据结构

![[Pasted image 20241208145345.png]]

	1.3 合理的数据结构编码
		Redis支持多种数据数据类型，每种基本类型可能对应多种数据结构。什么时候使用什么样的数据结构，使用什么样编码，是redis设计者总结优化的结果。

	（1）String：如果存储数字的话，是用int类型的编码;如果存储非数字，小于等于39字节的字符串，是embstr；大于39个字节，则是raw编码。
	
	（2）List：如果列表的元素个数小于512个，列表每个元素的值都小于64字节（默认），使用ziplist编码，否则使用linkedlist编码。
	
	（3）Hash：哈希类型元素个数小于512个，所有值小于64字节的话，使用ziplist编码,否则使用hashtable编码。
	
	（4）Set：如果集合中的元素都是整数且元素个数小于512个，使用intset编码，否则使用hashtable编码。
	
	（5）Zset：当有序集合的元素个数小于128个，每个元素的值小于64字节时，使用ziplist编码，否则使用skiplist（跳跃表）编码。


	1.4 高效的线程模型

	（1）IO多路复用
		I/O多路复用技术可以让单个线程高效的处理多个连接请求，而Redis使用用epoll作为I/O多路复用技术的实现。并且Redis自身的事件处理模型将epoll中的连接、读写、关闭都转换为事件，不在网络I/O上浪费过多的时间。
	
	（2）单线程
		Redis是单线程模型的，而单线程避免了CPU不必要的上下文切换和竞争锁的消耗。也正因为是单线程，如果某个命令执行过长（如hgetall命令），会造成阻塞。Redis是面向快速执行场景的数据库。，所以要慎用如smembers和lrange、hgetall等命令。
		
		Redis 6.0 引入了多线程提速，它的执行命令操作内存的仍然是个单线程。
	注：
		redis使用多线程并非是完全摒弃单线程，redis还是使用单线程模型来处理客户端的请求，只是使用多线程来处理数据的读写和协议解析，执行命令还是使用单线程。
		这样做的目的是因为redis的性能瓶颈在于网络IO而非CPU，使用多线程能提升IO读写的效率，从而整体提高redis的性能。


	1.5 虚拟内存机制

		虚拟内存机制就是暂时把不经常访问的数据(冷数据)从内存交换到磁盘中，从而腾出宝贵的内存空间用于其它需要访问的数据(热数据)。通过VM功能可以实现冷热数据分离，使热数据仍在内存中，冷数据保存到磁盘。这样可以避免因为内存不足而造成访问速度下降的问题。






